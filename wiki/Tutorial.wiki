#summary This is a brief tutorial on DEUS.

= Introduction =

Each release contains sources (in the src/ folder), docs and examples.
Sources include the following packages:

  * {{{it.unipr.ce.dsg.deus.automator}}} (classes for batch simulations with automatically changing parameters)
  * {{{it.unipr.ce.dsg.deus.automator.gui}}} (the GUI for managing batch simulations)
  * {{{it.unipr.ce.dsg.deus.core}}} (core interfaces and classes, such as Event, Node, Process)
  * {{{it.unipr.ce.dsg.deus.impl.event}}} (implementation of common events, such as node birth)
  * {{{it.unipr.ce.dsg.deus.impl.node}}} (implementation of basic node classes)
  * {{{it.unipr.ce.dsg.deus.impl.process}}} (implementation of common processes, such as Poisson)
  * {{{it.unipr.ce.dsg.deus.impl.resource}}} (implementation of basic resource classes)
  * {{{it.unipr.ce.dsg.deus.p2p.event}}} (P2P-specific events, such as connection)
  * {{{it.unipr.ce.dsg.deus.p2p.node}}} (P2P-specific node types, such as Peer)
  * {{{it.unipr.ce.dsg.deus.schema}}} (classes that map DEUS schema)
  * {{{it.unipr.ce.dsg.deus.schema.automator}}} (classes that map DEUS' XML schema)
  * {{{it.unipr.ce.dsg.deus.util}}} (utility classes)

Moreover, under the "examples" folder there are some useful simulation examples (with source code, configuration file and automator file).


= Configuring simulations =

The XML schema basically defines the following concepts: event, node, process, engine. 

In the "revol" example, there are several XML files configuring different simulations. In the following we refer to {{{FixedPop.xml}}}, which configures a simulation which creates a network of 10000 nodes.

Like any other XML file for the configuration of a DEUS-based simulation, you have to declare nodes like:

{{{
<aut:node id="revolNode" handler="it.unipr.ce.dsg.deus.example.revol.RevolPeer">
  <aut:params>
    <aut:param name="fitnessFunction" value="1" />
    <aut:param name="maxInitChromosome" value="6" />
    <aut:param name="isRandomInit" value="true" />
  </aut:params>
  <aut:resources>
    <aut:resource handler="it.unipr.ce.dsg.deus.impl.resource.AllocableResource">
      <aut:params>
        <aut:param name="type" value="cpuFactor" />
	<aut:param name="amount" value="4" /><!-- *512 MHz = 2GHz -->
      </aut:params>	
    </aut:resource>
    <aut:resource handler="it.unipr.ce.dsg.deus.impl.resource.AllocableResource">
      <aut:params>
	<aut:param name="type" value="ramFactor" />
	<aut:param name="amount" value="4" /><!-- *256 MB = 1GB -->
      </aut:params>	
    </aut:resource>
    <aut:resource handler="it.unipr.ce.dsg.deus.impl.resource.AllocableResource">
      <aut:params>
        <aut:param name="type" value="diskFactor" />
        <aut:param name="amount" value="10" /><!-- *10000 MB = 100GB -->
      </aut:params>	
    </aut:resource>
  </aut:resources>
</aut:node>
}}}

The handler must be a Java class in the classpath (this is a general rule, not only for nodes but also for resources, events, processes). Resources may be complex objects characterizing nodes (for this, they are not simply params of nodes, but entities with an associated handler which is the Java class defining the resource).

Other than nodes, you have to declare events, like:

{{{
<aut:event id="birth" handler="it.unipr.ce.dsg.deus.impl.event.BirthEvent" schedulerListener="it.unipr.ce.dsg.deus.example.revol.RevolBirthSchedulerListener" >
  <aut:events>
    <!-- events to be scheduled on created node -->
    <aut:reference id="connection" />
  </aut:events>
</aut:event>

<aut:event id="connection" handler="it.unipr.ce.dsg.deus.p2p.event.MultipleRandomConnectionsEvent" oneShot="true" >
  <aut:params>
    <aut:param name="isBidirectional" value="true" />
    <aut:param name="maxNumInitialConnections" value="3" />
  </aut:params>
</aut:event>
}}}

The "birth" event has an internal reference to another event, "connection", which is defined separately. This means that when a "birth" is scheduled, also a "connection" is scheduled (the timestamp of the referenced event is always greater than the rimestamp of the referencer). An event may have or not some parameters (e.g. "birth" has no params, while "connection" has params). An event can be one-shot, which means that it is executed only once, even though its time-regulating process is periodic.

Then, an event may be declared and instantiated in the Java code of another event. This approach is out of the control of the user that creates the XML configuration file.  

In the XML file, you may define processes which regulate the timeliness of events, like:

{{{
<aut:process id="rectpulseperiodic" handler="it.unipr.ce.dsg.deus.impl.process.RectangularPulsePeriodicProcess">
  <aut:params>
    <aut:param name="period" value="10" />
    <aut:param name="startVtThreshold" value="0" />
    <aut:param name="stopVtThreshold" value="100000" />
  </aut:params>
  <aut:nodes>
    <aut:reference id="revolNode" />
  </aut:nodes>
  <aut:events>
    <aut:reference id="birth" />
  </aut:events>
</aut:process>

<aut:process id="poisson2" handler="it.unipr.ce.dsg.deus.impl.process.PoissonProcess">
  <aut:params>
    <aut:param name="meanArrival" value="5" />
  </aut:params>
  <aut:nodes>
    <aut:reference id="revolNode" />
  </aut:nodes>
  <aut:events>
    <aut:reference id="connection" />
  </aut:events>
</aut:process>
}}}

Each process may refer to one or more node type, and to one or more events. A declared event cannot be associated to more than one declared process. Of course you can declare more events of the same type (e.g. "birth1" and "birth2" both handled by the same Java class) and associate them to the same process or to two different processes (which means differently declared processes, i.e. two processes with different id).

Finally, you have to declare which processes to run:
{{{
<aut:engine maxvt="2000000" seed="123456789"> 
  <aut:logger level="INFO" />
  <aut:processes>
    <aut:reference id="rectpulseperiodic" /> 
    <aut:reference id="periodic2" />
  </aut:processes>
</aut:engine>
}}}

Note: the engine does not refer to the poisson2 process, define above. This means that "connection" events are not directly scheduled by the engine. The latter schedules "birth" events, according to the "rectpulseperiodic" process. Each "birth" triggers the scheduling of a "connection", whose timestamp is automatically computed using the "poisson2" process. 


= DEUS Visual Editor =

Finally we have a visual editor that avoids to write the XML files manually, for configuring simulations.

To run the visual tool, supposing you have imported deus in Eclipse, create a "Run configuration" with the following features:

Project: deus

Main Class: it.unipr.ce.dsg.deus.editor.MainGUI

The user manual of the Visual Editor will be published in the "Downloads" section of this site. 


= Timestamps of events =

In the Event class, the scheduleReferencedEvents method creates and insert in the queue the events that are referred from the event scheduled by the Engine (example: BirthEvent references DiscoveryEvent).

If event X references events A, B and C, their triggering times are respectively:

* tA = tX + tGivenByProcessAssociatedToA

* tB = tX + tGivenByProcessAssociatedToB

* tC = tX + tGivenByProcessAssociatedToC

BE CAREFUL!

If you want that tA < tB <tC you need to create a reference chain:

* A references B

* B references C

for which C always comes after B, which always come after A.

Rememeber to implement all necessary scheduler listeners!!!


= Seeds =

The user sets a seed in the {{{<aut:engine>}}} tag. This seed is used to generate N seeds, one for each of the _declared_ events, to initialize its own Random Number Generator (RNG). In this way, for example, if the initial seed is S, and there are two declared events (e1 and e2), their respective seeds will be S1 and S2. If their scheduling is associated to a random process, if we configure the simulation to run both kinds of event, the schedules of their instances will be:
  * from S1, for e1: t11, t12, t13, etc.
  * from S2, for e2: t21, t22, t23, etc.
If we configure the simulationto run, for example, only e1, the schedules of its instances will be again: t11, t12, t13, etc.
If you modify the XML and declare another event e3 between the declaration of e1 and e2, in general the seeds will change (S1 will remain the same, S2 will become S3, and a new seed will be associated to e2). Be careful! Suggestion: declare all the events and use only those you need. If you add new events, add them after those already declared.


= Writing logs =

In DEUS, there are two logging strategies. One allows to have different logging granularity, by using Java instructions like

{{{
getLogger().fine(aLogMessage);
getLogger().info(anotherLogMessage);
}}}

and deciding which log messages to write by setting the logging level (info, fine, etc.) in the XML:

{{{
<aut:engine maxvt="2000000" seed="123456789"> 
  <aut:logger level="INFO" />
...
}}}

The other approach is the one for producing a log file whose format is good for the GUI automator, in order to produce 2D-graph Gnuplot data (i.e. files with x,y columns).
In your Log event, use the following code:

{{{
AutomatorLogger a = new AutomatorLogger("./temp/logger");
ArrayList<LoggerObject> fileValue = new ArrayList<LoggerObject>();
}}}

then, if you want to log the value of a variable called "var", use:

{{{
fileValue.add(new LoggerObject("var", value));
a.write(Engine.getDefault().getVirtualTime(), fileValue);
}}}


= Running simulations =

We suggest to import deus in Eclipse and to run the simulations from there.

Project: deus

Main Classes: 

{{{it.unipr.ce.dsg.deus.automator.gui.DeusAutomatorFrame}}} (Automator)

{{{it.unipr.ce.dsg.deus.core.Deus}}} (direct run)

Program Arguments: 
the first parameter passed is the path of the XML configuration file, while the second is the name of the XML file that will be generated by the Automator  

VM Arguments: {{{-Djava.util.logging.config.file=logging.properties -Xms256M -Xmx1000M}}}


Once the DEUS Automator GUI has loaded, you can configure which node paramaters, processes, etc. to vary in order to create many different simulations from the XML configuration file (that was introduced as first program argument).

For example, if a node has an integer parameter "x", you can add in the Node Parameter panel a rule to make "x" vary from an initial value, let say 1, to a final value, let say 5, with a step, e.g. 1. Then you can {{{Save}}} this configuration in a text file, to be reused in the future. If you press the {{{Run}}} button, 5 simulations are sequentially executed (one for each value of "x"). You can also set several seeds, other than default one, thus if you set 2 seeds, the number of simulations becomes 10.  

Very important is the {{{GnuPlot File}}} panel. Here you can define files in which to put bidimensional data to be plotted. 

For example, suppose that you have Logger that periodically computes the value of a variable "y". You can define a file (call it yVariation.txt, for example) with X label "VT" (virtual time) and Y Label "y". Then, after each simulation, you will have a yVariation.txt file reporting the values of y (first column) with respect to virtual time (second column). 